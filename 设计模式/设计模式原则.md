# 设计模式原则

## 开闭原则

对修改关闭，对扩展开放

实现方式：抽象约束，封装变化；通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

## 里氏替换原则

所有使用父类的地方，必须能够透明的使用子类对象

子类可以扩展父类的功能，但不能改变父类原有的功能。子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

## 依赖倒置原则

要面向接口编程，不要面向实现编程。

保持抽象层则相对稳定，细节可以具有多变性

## 单一职责原则

对象不应该承担太多职责，如果一个对象承担了太多的职责，则他应该被拆分

控制类的粒度大小、将对象解耦、提高其内聚性

优点：
- 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
- 提高类的可读性。复杂性降低，自然其可读性会提高。
- 提高系统的可维护性。可读性提高，那自然更容易维护了。
- 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

## 接口隔离原则

每个接口应该承担独立角色，不干自己不该干的事情

避免子类实现不需要实现的方法
需要对客户提供接口时，只需要暴露最小的接口

## 迪米特法则

只与你的直接朋友交谈，不跟“陌生人”说话

“朋友”是指：当前对象本身、当前对象的成员对象（如果还是集合，集合中元素也是朋友）、当前对象所创建的对象、当前对象的传入参数，可以直接访问这些对象的方法。

## 合成复用原则

尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

继承复用虽然有简单和易实现的优点，但它也存在以下缺点。
- 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
- 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
- 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。
- 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
- 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
- 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。


